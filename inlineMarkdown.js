import { createVisitor, createCompiler } from "./createCompiler.js"
export { inlineMarkdown }
/* prettier-ignore */ import {fooga, unreachable, notify, storager, joiner, removeVeryStartingComments, ireplace, removeCommentsInPlace, editf, getLineTokens, IndexedStore, abstractError, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, error, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendBelow, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, deepAssign, Tally, getFunctionNames, throwError, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, alert, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit, nchalk, coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, chalk, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, iterate, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, announce, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, Element, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, dictGetter, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, unzip, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"

const typeRef = {
    "**": "bold",
    __: "bold",
    "*": "italic",
    _: "italic",
    $: "inlineMath",
    $$: "blockMath",
    $$$: "blockMath",
    "```": "blockCode"
}

const inlineMathSpec = {
    type: "inlineMath",
    regex: /^\$(.*?)\$/,
    parse() {
        throw 'a'
    },
}

const inlineCodeSpec = {
    type: "inlineCode",
    regex: /^`(.*?)`/,
    parse() {
        throw 'addddddddddddddddddddddddddd'
    },
}

const operatorSpec = {
    type: "operator",
    regex: /^[-+*\/]/
}

const numberSpec = {
    type: "number",
    regex: /^\d+/
}

const punctuationSpec = { type: "punctuation", regex: /^[.?!]/ }
const spaceSpec = { type: "space", regex: /^\s+/ }
const wordSpec = {
    regex: /^[a-z]+(?:'[a-z]+)?/i,
    type: "word"
}

const hashSpec = {
    regex: /#\w+(?:\.\w+)*(?:\(.*?\)(?!\)))?/,
    type: "hash"
}
const delimSpec = {
    // you should not parse all the tokens at once
    // the token creation should actually be incremental
    // this is the only way to handle something like '***hi***'
    regex: /^(?:\*{1,2}|_{1,2})/,
    type: "delimiter",
    parse() {
        const expr = this.parseMultiple("Element", {
            parentType: "booga",
            whileTokens: true
        })
        this.eat("delimiter")
        return expr
    },
    visit(node) {
        return node.children.map((x) => this.visit(x)).join(" ")
    }
}
const visitGroup = {
    type: "Group",
    parse() {
        if (this.peekType("delimiter")) {
            const stopToken = this.eat("delimiter")
            const contents = this.parseUntil("Element", stopToken.value)
            this.eat("delimiter")
            return {
                contents,
                type: typeRef[stopToken.value]
                // kind: 'wrapper',
            }
        }
    },
    visit(node) {
        return parens(node.children.map((x) => this.visit(x)).join(" "))
    }
}
const visitProse = {
    type: "Prose",
    parse() {
        return this.accumulate(
            "Prose",
            "word",
            "space",
            "punctuation",
            "number"
        )
    }
}
const visitMath = {
    type: "Math",
    parse() {
        if (this.peekType("number")) {
            return this.accumulate("Math", "number", "space", "operator")
        }
    }
}
const visitElement = {
    type: "Element",
    parse() {
        return this.parseAny("Math", "Prose", "Group")
    }
}
const visitSentence = {
    type: "Sentence",
    main: true,
    parse() {
        const types = [
            "inlineCode",
            "inlineMath",
            "Element",
        ]
        return this.accumulate("Sentence", ...types)
    },
    visit(node) {
        return node.children.map((x) => this.visit(x)).join(" ")
    }
}
const MarkdownSpecs = [
    inlineCodeSpec,
    inlineMathSpec,
    hashSpec,
    delimSpec,
    wordSpec,
    spaceSpec,
    operatorSpec,
    punctuationSpec,
    numberSpec,

    // visitMath,
    visitProse,
    visitGroup,
    visitElement,
    visitSentence
]

const afterString = `
mode       katex      join    wrapper     template
italic     textit
bold       textbf
inlineMath fooga      true    
Prose                                     
`
function stringer(s) {
    // splits a string into an object array
    // the strings need to line up approproiately
    const split = (s) => {
        const r = /\S+/g
        const m = matchall(s, r).map((item, i) => {
            return {
                value: item[0],
                index: item.index
            }
        })
        return m
    }

    const [heading, rows] = splitOnce(s.trim().split("\n"))
    const headings = split(heading)
    const indexes = headings.map((heading) => heading.index)
    const headingNames = headings.map((heading) => heading.value)
    const parts = []

    for (let i = 0; i < indexes.length - 1; i++) {
        const [a, b] = indexes.slice(i, i + 2)
        parts.push([a, b - 1])
    }
    parts.push([getLast(indexes), Infinity])

    const payload = rows.map((row) => {
        const sections = parts.map((part) => row.slice(...part).trim())
        return sections.reduce((acc, el, i) => {
            if (!hasValue(el)) {
                return acc
            }
            const headingKey = headingNames[i]
            acc[headingKey] = toArgument(el)
            return acc
        }, {})
    })
    return payload
}
function stringer1(s) {
    const items = s
        .trim()
        .split("\n")
        .map((x) => xsplit(x))
    const heading = items.shift()
    throw heading
    const payload = items.map((row) => {
        return heading.reduce((acc, el, i) => {
            acc[heading[i]] = isDefined(row[i]) ? toArgument(row[i]) : false
            return acc
        }, {})
    })
    return payload
}
// console.log(stringer(s))
// console.log(str(s))
function simpleComponent(component, value) {
    return { component, value }
}

const visitorRef = {
    inlineMath: {
        wrapper(value) {
            return simpleComponent('v-katex', value)
        },
        inner: {
            Math: {
                apply: str,
            },
            bold: {
                apply: textbf,
            },
        }
    },
    Sentence: {
        wrapper(value) {
            throw 'aa'
            throw value
        },
        abstract: true
    }
}
const inlineMathRef = {
    Math(node) {
        return str(node)
    },
    bold(node, ref) {
        return textbf(this.visitChildrenWithRef(node, ref).join(""))
    },
}
const visitRef = {
    Sentence(node) {
        // abstract
        const children = this.visitChildren(node).filter(isObject)
        return {
            tag: 'p',
            class: 'md-sentence',
            children
        }
    },
    inlineMath(node) {
        return simpleComponent('v-katex', node.value)
    },
    bold(node, ref) {
        const value = {
            tag: 'em',
            value: this.visitChildren(node, true).join('')
        }
        return value
    },
    Prose(node, real) {
        const value = str(node).trim()
        if (real) {
            return value
        }
        if (!value) {
            return 
        }
        return {
            tag: 'span',
            value
        }
    },
    inlineCode(node) {
        return {
            component: 'v-code',
            value: node.value,
        }
    }
}

function str(node) {
    const str = node.contents.map((x) => x.value).join("")
    return str
}

const reducer = (acc, { mode, katex, join, wrapper, template }) => {
    const fn = (value) => {
        value = xjoin(value, join)
        if (template) {
            return templater(template, value)
        }
        if (katex) return `\\${katex}{${value}}`
    }
    acc[mode] = fn
    return acc
}
// throw stringer(afterString)
// const after = stringer(afterString).reduce(reducer, {})
function textbf(s) {
    return `\\textbf{${s}}`
}
function dollars(s) {
    return wrap(s, '$')
}
const opts = {
    // highlyOptionedVisitorRef: true,
    childrenKey: 'contents',
    // after: after
}
const visitor = createVisitor(visitRef, opts)
const compiler = createCompiler(MarkdownSpecs)
let s = "`hi`   **howdy** $2 + 3 + 123$ yeah pretty cool"
// let s = "$2 + *3*$ is `a*b*c`"
// const ast = compileMarkdown(s, { mode: "ast" })
// console.loggg(ast)
// console.log(visitor.visit(ast))
// console.loggg(ast)

function inlineMarkdown(s) {
    const opts = { mode: "ast" }
    return visitor.visit(compiler(s, opts))
}
