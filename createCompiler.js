export { createCompiler, createVisitor }
/* prettier-ignore */ import { must, lastOf, firstOf,fooga, unreachable, notify, storager, joiner, removeVeryStartingComments, ireplace, removeCommentsInPlace, editf, getLineTokens, IndexedStore, abstractError, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, error, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendBelow, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, deepAssign, Tally, getFunctionNames, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, alert, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit, nchalk, coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, chalk, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, iterate, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, announce, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, Element, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, dictGetter, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, unzip, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"
function typed(type, value) {
    if (value == null) {
        return
    }
    if (isObjectWithKey(value, "type")) {
        return value
    }
    if (isArray(value)) {
        return { type, children: value }
    }
    if (type == "Group" || type == "Element") {
        return value
    }
    return { type, value }
}
class ExtendableVisitor {
    constructor(visitors, options) {
        this.visit = this.visit.bind(this)
        this.options = options

        const stringify = options.stringify
        const visitorKey = options.mode == 'json' ? 'jsonVisit' : 'visit'
        const componentAliases = this.options.componentAliases

        const createSimpleVisitor = () => {
            return function lambda(node) {
                const children = this.visitChildren(node)
                return {
                    ...node.state,
                    children,
                    type: node.type,
                    name: node.name || ''
                }
            }
        }
        const createPresetComponentVisitor = (key) => {
            const component = must(componentAliases, key)
            return function lambda(node) {
                return {
                    component,
                    value: node.computedText,
                    type: key,
                    name: node.name || '',
                }
            }
        }

        const create = (x) => {
            let fn = x[visitorKey]
            if (!fn) {
                return
            }
            const key = x.type
            if (fn == 'presetComponent') {
                fn = createPresetComponentVisitor(key)
            }
            else if (fn == 'simple') {
                fn = createSimpleVisitor()
            }
            const visit = fn.bind(this)
            // return [key, visit]

            const visitor = (node) => {
                const result = visit(node)
                if (options.mode == 'json' && isObject(result) && !result.type) {
                    result.type = node.type
                }
                return result
            }
            return [key, visitor]
        }

        this.visitors = isArray(visitors)
            ? reduce(visitors, create)
            : walk(visitors, (v) => v.bind(this))
    }

    refVisit(child, ref) {
        const fn = must(ref, child.type)
        return fn.call(this, child, ref)
    }
    visitChildrenWithRef(node, ref) {
        const visitor = (child) => {
            return this.refVisit(child, ref)
        }
        const kids = node.children || node.contents
        const children = kids.map(visitor).filter(isDefined)
        return children
    }

    visitChildren(node, ...args) {
        const visitor = (child) => {
            return this.visit(child, ...args)
        }
        const kids = node.children || node.contents
        const children = kids.map(visitor).filter(isDefined)
        const stylers = dictGetter(this.options, 'styles', node.name || node.type)
        if (stylers) {
            applyStylers(children, stylers, node.parent?.type)
        }
        return children
    }
    visit(node, ...args) {
        assert(node)
        const fn = must(this.visitors, node.type)
        const value = fn(node, ...args)
        return value
    }
}

class ExtendableParser {
    constructor(specs) {
        const create = (x) => [x.type, x.parse.bind(this)]
        this.parsers = reduce(specs, create)
        const getElements = (spec) => {
            return !spec.regex && spec.type
        }

        this.elementNames = mapFilter(specs, getElements)
        this.parseKey = specs.find((x) => x.main).type
    }
    parse(tokens) {
        try {
            this.tokens = tokens
            this.position = 0
            return this.parseSingleton(this.parseKey)
        } catch (e) {
            console.log(e)
            console.log("ERROR @ EXTENDABLE PARSER")
            console.log(getCaller())
            // console.log(this.tokens)
        }
    }
    parseAny(...types) {
        return firstOf(types, (x) => this.parseSingleton(x))
        // return
    }
    parseUntil(type, stopValue) {
        const children = []
        // console.log('aa')
        while (!this.eof()) {
            if (this.lookahead.value == stopValue) {
                return children
            }
            const child = this.parseSingleton(type)
            if (child) {
                children.push(child)
            }
        }
        return children
    }
    parseWrapped(type, inner) {
        ndy()
        if (this.peekType(type)) {
            // this.eat(type)
            const first = typed(type, this.eat(type))
            const body = this.parseMultiple(inner, {
                whileTokens: true,
                parentType: "booga"
            })
            this.eat(type)
            return {
                first,
                body
            }
        }
    }
    parseSingleton(type) {
        const inElements = this.elementNames.includes(type)
        if (inElements) {
            return typed(type, this.parsers[type]())
        } else if (this.peekType(type)) {
            return typed(type, this.eat(type))
        }
    }
    accumulate(parentType, ...types) {
        const store = []
        while (true) {
            const atom = this.parseAny(...types)
            if (atom) {
                store.push(atom)
            } else {
                break
            }
        }
        if (store.length) {
            return {
                contents: store,
                type: parentType
            }
        }
    }
    parseMultiple(type, o = {}) {
        const children = []
        while (true) {
            const child = this.parseSingleton(type)
            if (child) {
                children.push(child)
            } else if (o.whileTokens && !this.eof()) {
                this.assert(type)
                unreachable()
            } else {
                break
            }
        }
        return typed(o.parentType || type, children)
    }

    get lookahead() {
        return this.tokens[this.position]
    }
    peekType(type) {
        const token = this.tokens[this.position]
        if (token == null) {
            return false
        }
        const nextType = token.type
        return type === nextType
    }
    assert(type) {
        if (this.lookahead == null) {
            panic("the lookahead is null")
        }
        if (this.lookahead.type !== type) {
            panic(`Expected token type ${type}, but got ${this.lookahead.type}`)
        }
    }
    eat(expectedType) {
        let token = this.lookahead
        this.assert(expectedType)
        this.position++
        // console.log('success', expectedType)
        return token
    }

    eof() {
        return this.position >= this.tokens.length
    }
}
class ExtendableTokenizer {
    constructor(tokenSpecs) {
        this.tokenSpecs = tokenSpecs
    }
    tokenize(s) {
        this.tokens = []
        this.cursor = 0
        this.input = s
        while (this.parseNextToken()) {
            continue
        }
        return this.tokens
    }
    hasMoreTokens() {
        return this.cursor < this.input.length
    }

    matchfn(matcher, input) {
        const m = matcher(input)
        const { type, value } = m
        if (type == null) {
            return null
        }
        this.cursor += value.length
        return m
    }
    match(regex, input) {
        const matched = regex.exec(input)
        if (matched === null) {
            return null
        }

        this.cursor += matched[0].length
        return getMatch(matched)
    }

    getNextToken() {
        return this.tokens.shift()
    }
    parseNextToken() {
        if (!this.hasMoreTokens()) {
            return null
        }

        const input = this.input.slice(this.cursor)

        for (const spec of this.tokenSpecs) {
            if (spec.match) {
                let match = this.matchfn(spec.match, input)
                if (match == null) {
                    continue
                }
                this.tokens.push(match)
                return true
            }

            let match = this.match(spec.regex, input)

            if (match === null) {
                continue
            } else if (spec.skip) {
                // the token is recognized as a match
                // but we do not include it in this.tokens
                // example: whitespace
                return true
            } else if (spec.tokenize) {
                spec.tokenize.call(this, match, spec)
                return true
            } else {
                this.tokens.push({ value: match, type: spec.type })
                return true
            }
        }
        panic("Unexpected token: $1", input[0])
    }
}
function createCompiler(items) {
    const getParser = (spec) => {
        return spec.parse
    }
    const getTokenSpec = (spec) => {
        return spec.regex
    }
    const tokenSpecs = filter(items, getTokenSpec)
    const parsers = filter(items, getParser)

    const tok = new ExtendableTokenizer(tokenSpecs)
    const parser = new ExtendableParser(parsers)
    const visitor = createVisitor(items)

    return function compile(s, options = {}) {
        const tokens = tok.tokenize(s)
        const ast = parser.parse(tokens)
        return options.mode == "ast" ? ast : visitor.visit(ast)
    }
}

function createVisitor(items, options = {}) {
    if (options.highlyOptionedVisitorRef) {
        return new OptionedVisitor(items, options)
    }
    return new ExtendableVisitor(items, options)
}

class OptionedVisitor {
    constructor(ref, options) {
        this.visit = this.visit.bind(this)
        this.options = options
        this.ref = ref
    }
    visit(node) {
        return this._visit(node)
        try {
            return this._visit(node)
        } catch (e) {
            console.log(e)
            panic()
        }
    }
    _visit(node) {
        let value
        const base = must(this.ref, node.type)
        // console.log({base})
        const children = node[this.options.childrenKey]
        if (base.abstract) {
            value = children.map(this.visit)
        } else if (base.inner) {
            const mapper = (child) => {
                const inner = must(base.inner, child.type)
                if (inner.apply) {
                    return inner.apply(child)
                } else {
                    ndy()
                }
            }
            value = children.map(mapper)
        } else {
            value = children
        }
        if (base.join) {
            value = xjoin(value, base.join)
        }
        if (base.wrapper) {
            value = base.wrapper(value)
        }
        return value
    }
}

function str(node) {
    const str = node.contents.map((x) => x.value).join("")
    return str
}

function xjoin(value, join) {
    if (join && isArray(value)) {
        value = isBoolean(join) ? value.join("") : value.join(join)
    }
    return value
}
function applyStylers(children, stylers, grandparentType) {
    applyMargins(children, stylers.margins)
}
function applyMargins(children, margin) {
    if (!margin) {
        return 
    }
    function apply(child, key, value) {
        deepAssign(child.state || child, 'style', key, value)
    }

    if (margin.type == 'smart') {
        children.forEach((child, i) => {
            if (i == 0) {
                return 
            }
            apply(child, 'margin-top', fparse(margin.handler, child, i))
        })
    }
}
