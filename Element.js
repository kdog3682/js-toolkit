export {
    Element,
}


/* prettier-ignore */ import {abstractError, fooga, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, error, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendBelow, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, deepAssign, Tally, getFunctionNames, throwError, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, alert, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit, nchalk, coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, chalk, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, iterate, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, announce, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, dictGetter, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, unzip, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"
import { dictSetter } from "/home/kdog3682/2024-javascript/js-toolkit/MASAO.js"
import { traverse } from "/home/kdog3682/2024-javascript/js-toolkit/traverse.js"

class Element {
    set(...args) {
        dictSetter(this, ...args)
    }

    assign(...args) {
        // throw args
        // dictSetter2(this.state, ...args)
        deepAssign(this.state, ...args)
        // console.log(this.state, args)
        // dictSetter(this.state, ...args)
    }
    get nodeIndex() {
        // the index of the self relative to siblings 
        // it will always exist
        const selfIndex = this.parent.children.indexOf(this)
        return selfIndex
    }
    replaceWith(node) {
        // returns the newly inserted node
        return this.parent.replaceNode(this, node)
    }
    replaceNode(refNode, node) {
        // returns the newly inserted node
        const a = this.create(node)
        this.children[refNode.nodeIndex] = a
        return a
    }
    go(distance) {
        typeAssertion(distance, Number)

        let current = this
        if (distance < 0) {
            for (let i = 0; i < -1 * distance; i++) {
                current = current.parent
            }
        } else {
            for (let i = 0; i < distance; i++) {
                current = current.firstChild
            }
        }
        return current
    }
    get size() {
        return this.children.length
    }

    get root() {
        return this.parent ? this.parent.root : this
    }

    constructor(state, parent) {
        this.children = []
        this.state = {}
        Object.assign(this, state)
        this.setParent(parent)
    }
    setParent(parent) {
        if (parent == null) {
            this.uid = 0
        } else {
            this.parent = parent
            this.uid = parent.uid + parent.size + 1
        }
        return this
    }

    get prevSibling() {
        if (!this.parent) {
            return null
        }
        if (this.parent.size == 1) return null
        let index = this.parent.children.indexOf(this)
        if (index == 0) return null
        return this.parent.children[index - 1]
    }
    get nextSibling() {
        if (!this.parent) {
            return null
        }
        const size = this.parent.size
        return this.parent.children[this.nodeIndex + 1]
    }

    get siblings() {
        if (!this.parent) return []
        return this.parent.children.filter((x) => x != this)
    }
    get numSiblings() {
        return this.siblings.length
    }
    get lastChild() {
        return this.children && this.children[this.size - 1]
    }
    get firstChild() {
        return this.children[0]
    }
    hasChildren() {
        return this.children.length > 0
    }
    isLeaf() {
        return this.children.length == 0
    }
    isRoot() {
        return this.uid == 0
    }
    isBranch() {
        return this.children.length > 0
    }
    prev() {
        return this.prevSibling || this.parent
    }
    insertNodeBefore(refNode, node, done) {
        const a = this.create(node, done)
        insertBeforeIndex(this.children, refNode.nodeIndex, a)
        return a
    }

    insertNodeAfter(refNode, node, done) {
        const a = this.create(node, done)
        insertAfterIndex(this.children, refNode.nodeIndex, a)
        return a
    }
    next() {
        return this.firstChild || this.nextSibling
    }
    appendChild(child) {
        return push2(this.children, this.create(child))
    }
    create(x) {
        const child = isClassObject(x)
            ? x.setParent(this)
            : new this.constructor(x, this)

        return child
    }
    prependChild(child) {
        return unshift2(this.children, this.create(child))
    }
    enter() {
        return this.lastChild
    }
    exit(n = 1) {
        return this.go(n * -1)
    }
    remove(x) {
        const remove = (child) => {
           this.children.splice(child.nodeIndex, 1)[0]
        }
        if (isArray(x)) {
            x.forEach(remove)
        } else if (x) {
            remove(x)
        } else {
            pop2(this.parent.children, this)
        }
    }
    traverse(fn) {
        return traverse(this, fn)
    }

    toRepr(fn) {
        const runner = (state) => {
            if (state.children.length) {
                const children = filter(state.children.map(runner))
                return fn(state, children)
            }
            return fn(state)
        }
        return runner(this)
    }
    toJSON(fn) {
        abstractError('use this.toRepr with a json fn')
    }

    toString(fn) {
        abstractError('use this.toRepr with a stringify fn')
    }

    // toString(fn) {
        // const body = this.children.map((child) => {
            // return child.toString(fn)
        // })
        // const children = mapFilter(this.children, (x) => x.toString(fn))
        // return fn(this, children)
    // }
    get isLastChild() {
        return this.parent.lastChild == this
    }
    get isFirstChild() {
        return this.parent.firstChild == this
    }
    findSiblings(o) {
        const {from, to} = o
        let potentials = this.parent.children
        if (from == 'self') {
             potentials = potentials.slice(this.nodeIndex + 1)
        }
        else if (from.type == 'self') {
             potentials = potentials.slice(this.nodeIndex)
        }

        if (o.while) {
            const type = o.while.type == 'self'
                ? this.type : o.while.type
            let i = 0
            for (i = 0; i < potentials.length; i++) {
                const child = potentials[i]
                if (child.type != this.type) {
                    break
                }
            }
            const children = potentials.slice(0, i)
            return booga(children)
        }
        if (to.type) {
            let i = potentials.findIndex((c) => c.type == to.type)
            if (i == -1) {
                return potentials
            }
            if (to.offset) {
                i += to.offset
            }
            // console.log({i})
            potentials = potentials.slice(0, i)
        }
        const children = potentials
        return booga(children)
    }

    isDone(done) {
        if (isDefined(done)) {
            this._done = done
        }
        return this._done
    }
    is(type) {
        return this.type == type
    }

    append(x) {
        const append = (x) => this.appendChild(x)
        if (isArray(x)) {
            x.forEach(append)
        } else {
            append(x)
        }
    }
    deleteSilently(x) {
        // if (!this.deletions) {
            // this.deletions = []
        // }
        // this.deletions.push(...toArray(x))
        const deleter = (child) => {
            // child.type = 'deleted'
            // this.children[child.index] = null
            // console.log('deleting')
        }
        x.forEach(deleter)
    }
}

function booga(potentials) {
    const texts = potentials.map((potential) => potential.contents[0]?.text)
        console.log(texts)
    return potentials
    // not in use
}
