
export {
    traverse,
    simpleTraverse,
    Traversal,
    inAndOut,
}
/* prettier-ignore */ import {fooga, abstractError, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, error, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendBelow, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, deepAssign, Tally, getFunctionNames, throwError, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, alert, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit, nchalk, coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, chalk, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, iterate, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, announce, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, Element, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, dictGetter, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, unzip, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"
import { dictSetter } from "/home/kdog3682/2024-javascript/js-toolkit/MASAO.js"

function inAndOut(node, traversal = {}, options = {}) {
    const {
        onBeforeStart,
        onBeforeEnd,
        onStart,
        onEnd,

        onRootEnter,
        onRootExit,

        onEnter,
        onExit,

        onBranchEnter,
        onBranchExit,

        onLeafEnter,
        onLeafExit,
    } = traversal

    assignFresh(options, {
        direction: 'forward',
    })

    function _traverse(node) {
        if (node.isDone()) {
            return
        }
        const isBranch = node.isBranch()
        const isRoot = node == origin

        if (isRoot) {
            if (onRootEnter) {
                result = onRootEnter(node)
            }
            else if (onBranchEnter) {
                result = onBranchEnter(node)
            }
        } else if (onEnter) {
            result = onEnter(node)
        } else if (isBranch) {
            if (onBranchEnter) {
                // throw onBranchEnter
                result = onBranchEnter(node)
            }
        } else {
            if (onLeafEnter) {
                result = onLeafEnter(node)
            }
        }

        if (result === false) {
            return 
        }

        if (options.direction == "forward") {
            for (let i = 0; i < node.children.length; i++) {
                result = _traverse(node.children[i])
                if (result === false) {
                    break
                }
            }
        } else {
            for (let i = node.children.length - 1; i >= 0; i--) {
                result = _traverse(node.children[i])
                if (result === false) {
                    break
                }
            }
        }

        if (isRoot) {
            if (onRootExit) {
                return onRootExit(node)
            }
            else if (onBranchExit) {
                return onBranchExit(node)
            }
        } else if (onExit) {
            return onExit(node)
        } else if (isBranch) {
            if (onBranchExit) {
                return onBranchExit(node)
            }
        } else {
            if (onLeafExit) {
                return onLeafExit(node)
            }
        }
    }

    let origin = node
    let result = null

    if (node.isDone()) {
        return
    }

    if (onBeforeStart) {
        result = onBeforeStart(node)
    }

    if (onStart) {
        result = onStart(node)
    }
    if (result === false) {
        return 
    }

    _traverse(node)

    if (onBeforeEnd) {
        onBeforeEnd(node)
    }

    if (onEnd) {
        return onEnd(node)
    }
}

function traverse(node, fn, key = "postOrderTraverse") {
    let count = 0

    function postOrderTraverse(state) {
        const children = state.children
        for (let i = 0; i < children.length; i++) {
            postOrderTraverse(children[i])
        }
        fn(state, count++)
        return state
    }

    function postOrderReverseTraverse(state) {
        const children = state.children
        for (let i = children.length - 1; i >= 0; i--) {
            postOrderReverseTraverse(children[i])
        }
        fn(state, count++)
        return state
    }

    function preOrderTraverse(state) {
        fn(state, count++)
        const children = state.children
        for (let i = 0; i < children.length; i++) {
            preOrderTraverse(children[i])
        }
        return state
    }
    function preOrderReverseTraverse(state) {
        fn(state, count++)
        const children = state.children
        for (let i = children.length - 1; i >= 0; i--) {
            preOrderReverseTraverse(children[i])
        }
        return state
    }

    const ref = {
        preOrderTraverse,
        preOrderReverseTraverse,
        postOrderTraverse,
        postOrderReverseTraverse
    }

    const runner = ref[key]
    return runner(node)
}



class Traversal {
    // traversalConfig is a object: {onEnter, onEnd}
    // et cetera
    constructor(traversalConfig, state = {}) {
        this.state = state
        this.load = this.load.bind(this)
        this.traversalConfig = traversalConfig.blocks
            ? this.abcde(traversalConfig)
            : dict(traversalConfig, this.load)
    }
    abcde(config) {
        const keys = [
            "onEnter",
            "onExit",
            "onBranchEnter",
            "onBranchExit",
            "onLeafEnter",
            "onLeafExit",
        ]

        const store = {}
        const create = (block) => {
            const fnKeys = keys.filter((key) => block[key])
            for (const fnKey of fnKeys) {
                const fn = this.load(block[fnKey])
                deepAssign(store, fnKey, [[block.type, fn]])
            }
        }
        config.blocks.forEach(create)
        const fnRef = dict(store, (items) => {
            const handler = (node, ...args) => {
                if (node.isDone()) {
                    return false
                }
                for (const [key, fn] of items) {
                    if (node.is(key)) {
                        return fn(node, ...args)
                    }
                }
            }
            return handler
        })
        const others = difference(Object.keys(config), ['blocks'])
        for (const other of others) {
            fnRef[other] = this.load(config[other])
        }
        return fnRef
    }

    traverse(node) {
        return inAndOut(node, this.traversalConfig)
    }
    load(v) {
        switch (type(v)) {
            case "Object":
                return this.loadObject(v)
            case "Array":
                return this.loadArray(v)
            case "Function":
                return v.bind(this.state)
            default:
                throw new Error('only able to load objects, arrays, and functions')
        }
    }
    loadObject(v) {
        if (v.is) {
            return this.loadObjectIs(v.is)
        }
        if (v.postOrderTraverse) {
            const runner = this.loadObject(v.postOrderTraverse)
            return function handler(node) {
                return node.traverse(runner)
            }
        }
    }
    loadObjectIs(o) {
        const items = Object.entries(o)
        const handler = (node, ...args) => {
            if (node.isDone()) {
                return false
            }
            for (const [key, fn] of items) {
                if (node.is(key)) {
                    return fn.call(this.state, node, ...args)
                }
            }
        }
        return handler
    }

    loadArray(configs) {
        const computedConfigs = configs.map((config, i) => {
            if (config.traversal) {
                config.traversal = new Traversal(config.traversal)
            }
            return config
        })

        const handler = (node) => {
            if (node.isDone()) {
                return false
            }
            for (const config of computedConfigs) {
                const m = this.arrayNodeWrapper(node, config)
                if (m) {
                    return m
                }
            }
        }
        return handler
    }

    arrayNodeWrapper(node, item) {
        if (node.isDone()) {
            return 
        }
        const m = match(node.text, item.regex)
        if (!m) {
            return
        }

        const args = toArray(m)
        const input = item.traversal
            ? item.traversal.traverse(node)
            : node

        const value = item.handler.call(this.state, input, ...args)

        if (item.assign == "parent") {
            node.parent.assign(value)
        } else if (item.assign == "self") {
            node.assign(value)
        }

        if (item.remove) {
            node.deleteSilently()
        }
        return true
    }
}

function simpleTraverse(node, visitor) {
    visitor(node)
    if (node.children) {
        node.children.forEach((child) => {
            simpleTraverse(child, visitor)
        })
    }
}
