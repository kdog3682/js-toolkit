import * as variables from "/home/kdog3682/2023/variables.js"
/* deno-fmt-ignore */ import {fooga, partitionByValues, strcall, getLongest2, must, mconfig, unreachable, notify, storager, joiner, removeVeryStartingComments, ireplace, removeCommentsInPlace, editf, getLineTokens, IndexedStore, abstractError, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, error, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendBelow, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, deepAssign, Tally, getFunctionNames, throwError, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, alert, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit, nchalk, coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, iterate, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, announce, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, Element, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, dictGetter, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, unzip, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"
export {
    cssLoader,
    getElement,
    getKeyListenerArg,
    googleFontLoader,
    elt,
    getInputState,
    getKeyAndType,
    importLoader,
    isInputElement,
    preventDefault,
    setRootAttributes,
}
function importLoader(imports) {
    return 
    function load(url) {
        const options = {
            tag: "link",
            parent: document.head,
            attributes: {
                href: url,
                rel: "stylesheet",
            },
        }
        return elt(options)
    }
    toArray2(imports).forEach(load)
}

function cssLoader(css) {
    if (isNode() || empty(css)) {
        return
    }

    if (isUrl(css)) {
        return elt({
            link: "style",
            parent: document.head,
            attributes: {
                href: css,
                rel: "stylesheet",
            },
        })
    }

    const options = {
        tag: "style",
        parent: document.head,
        innerHTML: css,
    }
    return elt(options)
}

function elt(o) {
    typeAssertion(o, Object)

    const className = o.class || o.className
    const attrs = o.attrs || o.attributes
    const html = o.innerHTML || o.html
    const style = o.style
    const svgNS = "http://www.w3.org/2000/svg"
    const getTag = () => {
        if (!attrs) {
            return "div"
        }
        if (attrs.rel) {
            return "link"
        }
        if (attrs.src) {
            return "script"
        }
        return "div"
    }

    const getParent = (x) => {
        if (tag == "script" || tag == "link") {
            return document.head
        }
    }

    const tag = o.tag || getTag()
    const parent = o.parent || getParent()
    const el = variables.svgTags.includes(tag)
        ? document.createElementNS(svgNS, tag)
        : document.createEl(tag)

    if (className) {
        el.className = className
    }
    if (attrs) {
        for (const [k, v] of Object.entries(attrs)) {
            el.setAttribute(k, v)
        }
    }
    if (html) {
        el.innerHTML = html
    }
    if (style) {
        console.log(style)
        Object.assign(el.style, style)
    }
    if (parent) {
        parent.appendChild(el)
    }
    return el
}

function getKeyAndType(e) {
    const keypressDict = {
        "Enter": { "name": "enter", "type": "actionKey" },
        "Escape": { "name": "escape", "type": "actionKey" },
        ",": { "name": "comma", "type": "symbolKey" },
        ".": { "name": "period", "type": "symbolKey" },
        ":": { "name": "colon", "type": "symbolKey" },
        "$": { "name": "dollar", "type": "symbolKey" },
        " ": { "name": "space", "type": "spaceKey" },
        "{": { "name": "leftCurlyBrace", "type": "symbolKey" },
        "}": { "name": "rightCurlyBrace", "type": "symbolKey" },
        "[": { "name": "leftSquareBrace", "type": "symbolKey" },
        "]": { "name": "rightSquareBrace", "type": "symbolKey" },
        "Tab": { "name": "tab", "type": "spaceKey" },
        "Backspace": {
            "name": "backspace",
            "type": "actionKey",
        },
        "ArrowUp": { "name": "up", "type": "arrowKey" },
        "ArrowRight": { "name": "right", "type": "arrowKey" },
        "ArrowLeft": { "name": "left", "type": "arrowKey" },
        "ArrowDown": { "name": "down", "type": "arrowKey" },
    }

    let key = e.key
    let arg = ""
    if (e.ctrlKey) {
        arg += "Control"
    }
    if (e.metaKey) {
        arg += "Meta"
    }
    if (e.altKey) {
        arg += "Alt"
    }
    if (e.shiftKey && key.length > 1) {
        arg += "Shift"
    }
    const keyName = arg + key
    const ref = keypressDict[key]
    const primaryType = arg
        ? "command"
        : ref
        ? ref.name
        : /\d/.test(key)
        ? "numberKey"
        : /[a-z]/.test(key)
        ? "letterKey"
        : "symbolKey"
    const secondaryType = ref?.type || ""
    return [keyName, primaryType, secondaryType]
}

function preventDefault(e) {
    if (isNode()) return
    /* skip ctrl-i  && ctrl-r  && ctrl-f */
    const keys = [
        "+",
        "-",
        "f",
        "i",
        "r",
    ]
    // console.log(e.key)
    if (e.ctrlKey && keys.includes(e.key)) {
        return
    }
    // e.preventDefault()
}
function isInputElement(e) {
    const stopPropagations = [
        "TEXTAREA",
        "INPUT",
    ]
    return stopPropagations.includes(e?.target?.tagName)
}

async function copyToClipboard(s) {
    try {
        await navigator.clipboard.writeText(stringify(s))
        return true
    } catch (e) {
        return false
    }
}

function setRootAttributes(o) {
    const root = document.documentElement

    function set(k, value) {
        const prefix = "--"
        const key = k.startsWith(prefix) ? k : prefix + k
        root.style.setProperty(key, value)
    }

    for (const [k, v] of Object.entries(o)) {
        set(k, v)
    }
}

function smoothScroll(pos, time) {
    var currentPos = window.pageYOffset
    var start = null
    if (time == null) time = 500
    if (isElement(pos)) {
        pos = pos.offsetTop
    }
    pos = +pos, time = +time
    window.requestAnimationFrame(function step(currentTime) {
        start = !start ? currentTime : start
        var progress = currentTime - start
        if (currentPos < pos) {
            window.scrollTo(
                0,
                ((pos - currentPos) * progress / time) +
                    currentPos,
            )
        } else {
            window.scrollTo(
                0,
                currentPos -
                    ((currentPos - pos) * progress / time),
            )
        }
        if (progress < time) {
            window.requestAnimationFrame(step)
        } else {
            window.scrollTo(0, pos)
        }
    })
}

function getInputState(e) {
    if (isInputElement(e) && e.key != "Tab") {
        return
    }
    preventDefault(e)
    return getKeyAndType2(e)
}

const keypressDict2 = {
    "Enter": { "name": "enter", "type": "action" },
    "Escape": { "name": "escape", "type": "action" },
    ",": { "name": "comma", "type": "symbol" },
    "/": { "name": "slash", "type": "symbol" },
    "\\": { "name": "backslash", "type": "symbol" },
    "(": { "name": "leftParentheses", "type": "symbol" },
    ")": { "name": "rightParentheses", "type": "symbol" },
    "?": { "name": "questionMark", "type": "symbol" },
    ".": { "name": "period", "type": "symbol" },
    ":": { "name": "colon", "type": "symbol" },
    "$": { "name": "dollar", "type": "symbol" },
    " ": { "name": "space", "type": "space" },
    "{": { "name": "leftCurlyBrace", "type": "symbol" },
    "}": { "name": "rightCurlyBrace", "type": "symbol" },
    "[": { "name": "leftSquareBrace", "type": "symbol" },
    "]": { "name": "rightSquareBrace", "type": "symbol" },
    "!": { "name": "exclamation", "type": "symbol" },
    "@": { "name": "at", "type": "symbol" },
    "#": { "name": "hash", "type": "symbol" },
    "$": { "name": "dollarSign", "type": "symbol" },
    "%": { "name": "percentSign", "type": "symbol" },
    "^": { "name": "caret", "type": "symbol" },
    "&": { "name": "ampersand", "type": "symbol" },
    "*": { "name": "asterisk", "type": "symbol" },
    "<": { "name": "lt", "type": "symbol" },
    ">": { "name": "gt", "type": "symbol" },
    "Tab": { "name": "tab", "type": "space" },
    "Backspace": { "name": "backspace", "type": "action" },
    "ArrowUp": { "name": "up", "type": "arrow" },
    "ArrowRight": { "name": "right", "type": "arrow" },
    "ArrowLeft": { "name": "left", "type": "arrow" },
    "ArrowDown": { "name": "down", "type": "arrow" },
    "0": { "name": "zero", "type": "number" },
    "1": { "name": "one", "type": "number" },
    "2": { "name": "two", "type": "number" },
    "3": { "name": "three", "type": "number" },
    "4": { "name": "four", "type": "number" },
    "5": { "name": "five", "type": "number" },
    "6": { "name": "six", "type": "number" },
    "7": { "name": "seven", "type": "number" },
    "8": { "name": "eight", "type": "number" },
    "9": { "name": "nine", "type": "number" },
}

function getKeyAndType2(e) {
    const keys = [
        "ctrlKey",
        "metaKey",
        "altKey",
    ]

    const ref = {
        "ctrlKey": "Control-",
        "metaKey": "Meta",
        "altKey": "Alt",
        "optionKey": "Option",
        "ctrlKey": "ctrl-",
        "metaKey": "meta-",
        "altKey": "alt-",
        "shiftKey": "shift-",
    }

    let arg = ""

    for (const key of keys) {
        arg += e[key] ? ref[key] : ""
    }
    if (e.shiftKey && e.key.length > 1) {
        arg += ref.shiftKey
    }
    arg += e.key

    const keyRef = keypressDict2[e.key]
    if (keyRef) {
        const { name, type } = keyRef
        return { name, type, arg }
    } else {
        return { type: "letter", arg, name: "" }
    }
}

function loadScript(src) {
    return new Promise((resolve, reject) => {
        console.log("loading script", src)
        const script = document.createElement("script")
        script.src = src
        script.onload = (x) => resolve(true)
        script.onerror = (x) => resolve(false)
        document.head.appendChild(script)
    })
}

const trigger = (el, etype, custom) => {
    const evt = custom ?? new Event(etype, { bubbles: true })
    el.dispatchEvent(evt)
}

const vHover = new CustomEvent(`virtualhover`, {
    bubbles: true,
    detail: `red`,
})

function handle(evt) {
    if (evt.target.id === `clickTrigger`) {
        trigger(document.querySelector(`#testMe`), `click`)
    }

    if (evt.type === `virtualhover`) {
        evt.target.style.color = evt.detail
        return setTimeout(
            (_) => evt.target.style.color = ``,
            1000,
        )
    }

    if (evt.target.id === `testMe`) {
        document.querySelector(`#testMeResult`)
            .insertAdjacentHTML(
                `beforeend`,
                `<p>One of us clicked #testMe.
        It was <i>${
                    evt.isTrusted
                        ? `<b>you</b>`
                        : `me`
                }</i>.</p>`,
            )
        trigger(
            document.querySelector(`#testMeResult p:last-child`),
            `virtualhover`,
            vHover,
        )
    }
}
// console.log(vHover)


const googleFontPresets = {
    "chinese": {
      "fontFamily": "Noto Sans SC",
      "fontWeight": "400",
      "fontStyle": "normal"
    },
    "elegant": {
      "fontFamily": "Playfair Display",
      "fontWeight": "400",
      "fontStyle": "italic"
    },
    "Serious": {
      "fontFamily": "Roboto",
      "fontWeight": "400",
      "fontStyle": "normal"
    },
    "Playful": {
      "fontFamily": "Comic Sans MS",
      "fontWeight": "400",
      "fontStyle": "normal"
    },
    "Professional": {
      "fontFamily": "Open Sans",
      "fontWeight": "400",
      "fontStyle": "normal"
    },
    "Bold": {
      "fontFamily": "Montserrat",
      "fontWeight": "700",
      "fontStyle": "normal"
    },

    "cursive": {
      "fontFamily": "Cedarville Cursive",
      "fontWeight": "500",
      "fontStyle": "normal"
    },
}

function windowCache(key, prefix = '___') {
    if (window[prefix + key]) {
        return true
    }
    window[prefix + key] = true
    return false
}
function googleFontLoader(fontFamily, fontWeight = 'normal', fontStyle = 'normal') {
    if (!fontFamily || windowCache(fontFamily)) {
        return 
    }
    return new Promise((resolve, reject) => {
        const fonts = 'family=' + fontFamily.replace(/[- ]/g, '+')
        const hrefBase = "https://fonts.googleapis.com/css2?$fonts&display=swap"
        const href = templater(hrefBase, {fonts})
        console.log(href)
        const linkElement = document.createElement('link');
        linkElement.href = href
        linkElement.rel = 'stylesheet'
        linkElement.onload = resolve
        linkElement.onerror = reject
        document.head.appendChild(linkElement);
    })
}


function getKeyListenerArg(e) {

    let key = e.key
    let arg = ""
    if (e.ctrlKey) {
        arg += "ctrl-"
    }
    if (e.metaKey) {
        arg += "meta-"
    }
    if (e.altKey) {
        arg += "alt-"
    }
    if (e.shiftKey && key.length > 1) {
        arg += "shift-"
    }

    if (key.startsWith('Arrow')) {
        arg += key.slice(5).toLowerCase()
    }
    else if (key == ' ') {
        arg += 'space'
    }
    else if (key.length > 1) {
        arg += key.toLowerCase()
    } else {
        arg += key
    }
    return arg
}
function getElement(x) {
    if (isString(x)) {
        if (/^[.#]/.test(x)) {
            return document.querySelector(x)
        }
        switch(x) {
            case 'window': window
            case 'body': document.body
            case 'document': document.body
            case 'activeElement': document.activeElement
            default: 
                throw new Error(`couldnt find element ${x}`)
        }
    }
    return x
}
